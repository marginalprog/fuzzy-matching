# Анализ результатов тестирования библиотеки fuzzy_matching

В данном документе представлен детальный анализ работы библиотеки fuzzy_matching, включая результаты тестирования производительности различных алгоритмов и их эффективности для разных типов данных.

## 1. Сравнение алгоритмов нечеткого сопоставления

Библиотека поддерживает пять различных алгоритмов нечеткого сопоставления, каждый из которых имеет свои особенности и области применения:

### 1.1. Анализ работы алгоритмов на строках

Алгоритмы показали следующие результаты при сопоставлении различных типов строк:

#### Точное совпадение ('Иванов Иван' и 'Иванов Иван'):
- **Все алгоритмы** показали 100% схожесть

#### Подстрока ('Иванов Иван' и 'Иванов Иван Иванович'):
- **RATIO**: 71.0% - базовый алгоритм не учитывает, что одна строка полностью содержится в другой
- **PARTIAL_RATIO**: 100.0% - определил полное включение одной строки в другую
- **TOKEN_SORT**: 71.0% - не учитывает включение при разной длине строк
- **TOKEN_SET**: 100.0% - учитывает наличие всех токенов из первой строки во второй
- **WRatio**: 90.0% - дает высокий, но не максимальный результат

#### Перестановка частей составного слова ('Петров-Чехов' и 'Чехов-Петров'):
- Все алгоритмы показали низкие результаты (58-67%) - сложный случай для алгоритмов

#### Перестановка слов ('Иван Сидорович' и 'Сидорович Иван'):
- **RATIO**: 64.3% - чувствителен к порядку слов
- **PARTIAL_RATIO**: 78.3% - лучше справляется с перестановкой
- **TOKEN_SORT**: 100.0% - идеально подходит для перестановки слов
- **TOKEN_SET**: 100.0% - также идеально для перестановки
- **WRatio**: 95.0% - хороший баланс

#### Уменьшительное имя ('John Smith' и 'Johnny Smith'):
- Большинство алгоритмов показали около 91% схожести
- **PARTIAL_RATIO**: 80.0% - ниже из-за особенностей алгоритма

#### Различный порядок и дополнительные слова ('The quick brown fox' и 'The brown fox was quick'):
- **RATIO**: 61.9% - низкий результат из-за различий в порядке и наличии дополнительного слова
- **PARTIAL_RATIO**: 81.2% - лучше справляется с частичным совпадением
- **TOKEN_SORT**: 90.5% - хорошо справляется с перестановкой
- **TOKEN_SET**: 100.0% - идеален при различном порядке слов и дополнительных словах
- **WRatio**: 95.0% - хороший баланс различных метрик

### 1.2. Анализ работы алгоритмов на реальных данных

При сопоставлении полных записей (ФИО, email) алгоритмы показали следующие результаты:

#### Запись с опечаткой (Иванович/Ивановч):
- Все алгоритмы показали высокую схожесть (98-99%)

#### Запись с перестановкой частей фамилии (Чехов-Петров/Петров-Чехов):
- Все алгоритмы показали схожесть около 83-87%
- **PARTIAL_RATIO**: 87% - лучший результат

#### Запись с перестановкой имени и отчества:
- Все алгоритмы показали низкую схожесть (58-62%)
- Это ожидаемо, так как поля имени и отчества поменялись местами

#### Англоязычные имена с уменьшительными формами:
- **PARTIAL_RATIO**: 100% - лучший результат для уменьшительных форм имени
- **WRatio**: 94% - также хороший результат

## 2. Анализ производительности

Были проведены тесты на наборах данных различного размера (100, 500, 1000 записей), с различными конфигурациями алгоритмов и настройками транслитерации.

### 2.1. Влияние размера данных на производительность

| Размер данных | Без транслитерации (сек) | С транслитерацией (сек) | Замедление |
|---------------|--------------------------|-------------------------|-----------|
| 100           | 0.0052                   | 0.015                   | 188%      |
| 500           | 0.0767                   | 0.264                   | 244%      |
| 1000          | 0.2867                   | 1.0016                  | 249%      |

Вывод: Время выполнения растет почти линейно с увеличением объема данных, при этом включение транслитерации увеличивает время обработки в 2.4-2.5 раза.

### 2.2. Влияние блокировки на производительность

| Размер данных | С блокировкой (сек) | Без блокировки (сек) | Замедление |
|---------------|---------------------|----------------------|-----------|
| 100           | 0.015               | 1.0805               | 7103%     |
| 500           | 0.264               | 27.5203              | 10324%    |
| 1000          | 1.0016              | 108.3083             | 10714%    |

Вывод: Блокировка (группировка данных по первому символу поля) критически важна для производительности. Без блокировки время выполнения возрастает в 70-107 раз, делая обработку больших наборов данных практически невозможной.

### 2.3. Сравнение производительности алгоритмов (данные 1000 записей)

| Алгоритм      | Без транслитерации (сек) | С транслитерацией (сек) | Замедление | Найдено совпадений |
|---------------|--------------------------|-------------------------|-----------|-------------------|
| RATIO         | 0.2867                   | 1.0016                  | 249%      | 868               |
| PARTIAL_RATIO | 0.3682                   | 1.0394                  | 182%      | 895               |
| TOKEN_SORT    | 0.2939                   | 1.0177                  | 246%      | 868               |
| TOKEN_SET     | 0.3214                   | 1.0452                  | 225%      | 868               |
| WRatio        | 0.3413                   | 1.0752                  | 215%      | 878               |

Выводы:
- Базовый алгоритм RATIO наиболее быстрый без транслитерации
- PARTIAL_RATIO находит больше совпадений и меньше страдает от включения транслитерации
- WRatio также находит больше совпадений, но является самым медленным
- Все алгоритмы замедляются примерно в 2-2.5 раза при включении транслитерации

### 2.4. Эффективность алгоритмов (записей в секунду)

| Алгоритм      | Без транслитерации | С транслитерацией | Падение эффективности |
|---------------|--------------------|--------------------|------------------------|
| RATIO         | 3488.14            | 998.41             | 71%                    |
| PARTIAL_RATIO | 2715.65            | 962.08             | 65%                    |
| TOKEN_SORT    | 3402.74            | 982.64             | 71%                    |
| TOKEN_SET     | 3111.22            | 956.75             | 69%                    |
| WRatio        | 2929.85            | 930.09             | 68%                    |

Вывод: При включении транслитерации эффективность алгоритмов падает на 65-71%. 

## 3. Предметно-ориентированные алгоритмы

Тестирование предметно-ориентированных наборов алгоритмов на трех типах данных показало следующие результаты:

### 3.1. Персональные данные

- Средняя схожесть с базовым алгоритмом: 0.78
- Средняя схожесть с предметно-ориентированным: 0.85
- Улучшение: 8.3%

Ключевые наблюдения:
- PARTIAL_RATIO для имен значительно улучшает обработку уменьшительных форм
- TOKEN_SORT для фамилий успешно обрабатывает двойные фамилии
- TOKEN_SET для адресов не зависит от порядка слов

### 3.2. Товары

- Средняя схожесть с базовым алгоритмом: 0.67
- Средняя схожесть с предметно-ориентированным: 0.81
- Улучшение: 16.9%
- Дополнительно: найдено на 25% больше совпадений

Ключевые наблюдения:
- TOKEN_SET наиболее эффективен для названий товаров, где порядок слов часто меняется
- PARTIAL_RATIO эффективен для брендов с различными написаниями
- RATIO необходим для точного сопоставления артикулов

### 3.3. Компании

- Средняя схожесть с базовым алгоритмом: 0.68
- Средняя схожесть с предметно-ориентированным: 0.72
- Улучшение: 5.3%
- Дополнительно: найдено на 25% больше совпадений

Ключевые наблюдения:
- TOKEN_SET идеален для названий компаний с различным порядком слов и организационно-правовыми формами
- RATIO критически важен для точного сопоставления ИНН и других цифровых идентификаторов

## 4. Рекомендации по выбору алгоритмов

На основе проведенного тестирования можно сформулировать следующие рекомендации:

### 4.1. По типам данных

#### Для персональных данных:
- **Имена**: PARTIAL_RATIO - лучше обрабатывает уменьшительные формы
- **Фамилии**: TOKEN_SORT - справляется с двойными фамилиями
- **Адреса**: TOKEN_SET - не зависит от порядка слов
- **Email, телефоны**: RATIO - обеспечивает точность

#### Для товаров:
- **Названия товаров**: TOKEN_SET - учитывает вариации в порядке слов
- **Описания**: TOKEN_SET - важен смысл, а не порядок слов
- **Артикулы, коды**: RATIO - требуется высокая точность
- **Бренды**: PARTIAL_RATIO - учитывает вариации в написании

#### Для компаний:
- **Названия организаций**: TOKEN_SET - учитывает вариации в форме собственности
- **Юридические наименования**: TOKEN_SET - порядок слов часто меняется
- **ИНН, КПП**: RATIO - требуется точность
- **Адреса**: TOKEN_SET - не зависит от порядка слов

### 4.2. Общие рекомендации

1. **Обязательно используйте блокировку** для больших наборов данных - это критически важно для производительности
2. **Применяйте транслитерацию только к необходимым полям** (имя, фамилия) для оптимизации производительности
3. **WRatio** является наиболее универсальным алгоритмом для неспециализированных задач
4. **PARTIAL_RATIO** лучше всего для поиска уменьшительных форм и вариаций имен
5. **TOKEN_SET** оптимален при нефиксированном порядке слов
6. Повышайте порог схожести (>0.9) для более строгого отбора совпадений

## 5. Выводы

1. Применение предметно-ориентированных алгоритмов повышает точность сопоставления на 5-17% в зависимости от типа данных.
2. Включение транслитерации увеличивает время обработки в 2.4-2.5 раза, но критически важно для многоязычных данных.
3. Блокировка по первой букве ускоряет работу в 70-107 раз при больших объемах данных.
4. Комплексный подход с выбором оптимального алгоритма для каждого типа поля обеспечивает наилучший баланс между точностью и производительностью.
5. Транслитерация между русским и английским языками позволяет обрабатывать разноязычные варианты написания имен с высокой точностью. 